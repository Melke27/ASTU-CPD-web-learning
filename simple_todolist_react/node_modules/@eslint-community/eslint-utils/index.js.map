{"version":3,"file":"index.js","sources":["src/get-innermost-scope.mjs","src/find-variable.mjs","src/token-predicate.mjs","src/get-function-head-location.mjs","src/get-static-value.mjs","src/get-string-if-constant.mjs","src/get-property-name.mjs","src/get-function-name-with-kind.mjs","src/has-side-effect.mjs","src/is-parenthesized.mjs","src/pattern-matcher.mjs","src/reference-tracker.mjs","src/index.mjs"],"sourcesContent":["/** @typedef {import(\"eslint\").Scope.Scope} Scope */\n/** @typedef {import(\"estree\").Node} Node */\n\n/**\n * Get the innermost scope which contains a given location.\n * @param {Scope} initialScope The initial scope to search.\n * @param {Node} node The location to search.\n * @returns {Scope} The innermost scope.\n */\nexport function getInnermostScope(initialScope, node) {\n    const location = /** @type {[number, number]} */ (node.range)[0]\n\n    let scope = initialScope\n    let found = false\n    do {\n        found = false\n        for (const childScope of scope.childScopes) {\n            const range = /** @type {[number, number]} */ (\n                childScope.block.range\n            )\n\n            if (range[0] <= location && location < range[1]) {\n                scope = childScope\n                found = true\n                break\n            }\n        }\n    } while (found)\n\n    return scope\n}\n","import { getInnermostScope } from \"./get-innermost-scope.mjs\"\n/** @typedef {import(\"eslint\").Scope.Scope} Scope */\n/** @typedef {import(\"eslint\").Scope.Variable} Variable */\n/** @typedef {import(\"estree\").Identifier} Identifier */\n\n/**\n * Find the variable of a given name.\n * @param {Scope} initialScope The scope to start finding.\n * @param {string|Identifier} nameOrNode The variable name to find. If this is a Node object then it should be an Identifier node.\n * @returns {Variable|null} The found variable or null.\n */\nexport function findVariable(initialScope, nameOrNode) {\n    let name = \"\"\n    /** @type {Scope|null} */\n    let scope = initialScope\n\n    if (typeof nameOrNode === \"string\") {\n        name = nameOrNode\n    } else {\n        name = nameOrNode.name\n        scope = getInnermostScope(scope, nameOrNode)\n    }\n\n    while (scope != null) {\n        const variable = scope.set.get(name)\n        if (variable != null) {\n            return variable\n        }\n        scope = scope.upper\n    }\n\n    return null\n}\n","/** @typedef {import(\"eslint\").AST.Token} Token */\n/** @typedef {import(\"estree\").Comment} Comment */\n/** @typedef {import(\"./types.mjs\").ArrowToken} ArrowToken */\n/** @typedef {import(\"./types.mjs\").CommaToken} CommaToken */\n/** @typedef {import(\"./types.mjs\").SemicolonToken} SemicolonToken */\n/** @typedef {import(\"./types.mjs\").ColonToken} ColonToken */\n/** @typedef {import(\"./types.mjs\").OpeningParenToken} OpeningParenToken */\n/** @typedef {import(\"./types.mjs\").ClosingParenToken} ClosingParenToken */\n/** @typedef {import(\"./types.mjs\").OpeningBracketToken} OpeningBracketToken */\n/** @typedef {import(\"./types.mjs\").ClosingBracketToken} ClosingBracketToken */\n/** @typedef {import(\"./types.mjs\").OpeningBraceToken} OpeningBraceToken */\n/** @typedef {import(\"./types.mjs\").ClosingBraceToken} ClosingBraceToken */\n/**\n * @template {string} Value\n * @typedef {import(\"./types.mjs\").PunctuatorToken<Value>} PunctuatorToken\n */\n\n/** @typedef {Comment | Token} CommentOrToken */\n\n/**\n * Creates the negate function of the given function.\n * @param {function(CommentOrToken):boolean} f - The function to negate.\n * @returns {function(CommentOrToken):boolean} Negated function.\n */\nfunction negate(f) {\n    return (token) => !f(token)\n}\n\n/**\n * Checks if the given token is a PunctuatorToken with the given value\n * @template {string} Value\n * @param {CommentOrToken} token - The token to check.\n * @param {Value} value - The value to check.\n * @returns {token is PunctuatorToken<Value>} `true` if the token is a PunctuatorToken with the given value.\n */\nfunction isPunctuatorTokenWithValue(token, value) {\n    return token.type === \"Punctuator\" && token.value === value\n}\n\n/**\n * Checks if the given token is an arrow token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is ArrowToken} `true` if the token is an arrow token.\n */\nexport function isArrowToken(token) {\n    return isPunctuatorTokenWithValue(token, \"=>\")\n}\n\n/**\n * Checks if the given token is a comma token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is CommaToken} `true` if the token is a comma token.\n */\nexport function isCommaToken(token) {\n    return isPunctuatorTokenWithValue(token, \",\")\n}\n\n/**\n * Checks if the given token is a semicolon token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is SemicolonToken} `true` if the token is a semicolon token.\n */\nexport function isSemicolonToken(token) {\n    return isPunctuatorTokenWithValue(token, \";\")\n}\n\n/**\n * Checks if the given token is a colon token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is ColonToken} `true` if the token is a colon token.\n */\nexport function isColonToken(token) {\n    return isPunctuatorTokenWithValue(token, \":\")\n}\n\n/**\n * Checks if the given token is an opening parenthesis token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is OpeningParenToken} `true` if the token is an opening parenthesis token.\n */\nexport function isOpeningParenToken(token) {\n    return isPunctuatorTokenWithValue(token, \"(\")\n}\n\n/**\n * Checks if the given token is a closing parenthesis token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is ClosingParenToken} `true` if the token is a closing parenthesis token.\n */\nexport function isClosingParenToken(token) {\n    return isPunctuatorTokenWithValue(token, \")\")\n}\n\n/**\n * Checks if the given token is an opening square bracket token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is OpeningBracketToken} `true` if the token is an opening square bracket token.\n */\nexport function isOpeningBracketToken(token) {\n    return isPunctuatorTokenWithValue(token, \"[\")\n}\n\n/**\n * Checks if the given token is a closing square bracket token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is ClosingBracketToken} `true` if the token is a closing square bracket token.\n */\nexport function isClosingBracketToken(token) {\n    return isPunctuatorTokenWithValue(token, \"]\")\n}\n\n/**\n * Checks if the given token is an opening brace token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is OpeningBraceToken} `true` if the token is an opening brace token.\n */\nexport function isOpeningBraceToken(token) {\n    return isPunctuatorTokenWithValue(token, \"{\")\n}\n\n/**\n * Checks if the given token is a closing brace token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is ClosingBraceToken} `true` if the token is a closing brace token.\n */\nexport function isClosingBraceToken(token) {\n    return isPunctuatorTokenWithValue(token, \"}\")\n}\n\n/**\n * Checks if the given token is a comment token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is Comment} `true` if the token is a comment token.\n */\nexport function isCommentToken(token) {\n    return [\"Block\", \"Line\", \"Shebang\"].includes(token.type)\n}\n\ne